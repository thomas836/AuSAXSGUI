function [fvec,alpha]=fms5_new(sval,Dvec,Sigvec,RMAT,CMAT,ALPHA_STOP,Szero,Xlog)%% Skilling MEMSYS5 "hidden-space" algorithm for constructing an h distribition% using QUADRATIC ENTROPY.%% Usage: [hvec,fvec,sfvec,cscas,alpha]=fms5(sval,Dvec,Sigvec,RMAT,CMAT,ALPHA_STOP,Szero,VERBlog,Xlog);%% Inputs:   sval        values of s for the data%           Dvec        data %			Sigvec      sig_data%			RMAT        basis functions matrix%			CMAT        intrinsic corellation function matrix%			ALPHA_STOP  stopping reg. constant%			Szero       the S index above which I(s) goes to zero%			Xlog        if ==0 no cross-validation; <0 uses random Mod; >0 Mod=Xlog-1%			VERBlog     if ==1 verbose output; ==0 minimal output; <0 I/O file#=-VERBlog%% Outputs:	hvec        hidden space distribution%			fvec        visible space distribution%			sfvec       sigma of visible space distribution%			cscas       square of the noise scaling factor%			alpha       regularization constant (temperature analog)%%		REMEMBER TO global hvec alpha%X_INTERVALS=5;X_INTERVAL_FRAC=0.02;TOLX=10^-3;TOLA=10^-4;GTOL=10^-3;EPS =3*10^-8;STPM=100.0;BASEPRESS=0.1;ITSMAX=200;tol=0.01;OMEGA_STOP=1; COOLRATE=1.1;OMEGA_SWITCH=	[-Inf 10^-5 10^-4 10^-3 10^-2  10^-1  0.7];COOLRATES=		[ 3.0  3.0   3.0   1.4   1.4    1.4   1.1];% format='%10.3g %10.3g %10s %10.3g %10.3g %10.3g %10.3g %10.2g %10.2g %10.3g %10.2g %5d\n';% sformat='%10s %10s %10s %10s %10s %10s %10s %10s %10s %10s %10s %5s\n';%Ndim=length(Dvec); Ndim1=length(Sigvec);[Ndim2, Mdim]=size(RMAT); [Mdim1, Ldim]=size(CMAT);if (Ndim~=Ndim1 || Ndim~=Ndim2 || Mdim~=Mdim1)	disp('Dimension mismatch in get_h');	return;endif (min(abs(Sigvec))==0)     disp('!!! Zeros in standard deviation vector !!!');     return;end% FIO=1; % % if (VERBlog > 0)%     FIO=-VERBlog;%     VERBlog=0;% endInd=1:1:Ndim;% gveca=zeros(Ldim,1); gvecb=zeros(Ldim,1); grLvec=zeros(Ldim,1); grSvec=zeros(Ldim,1); deluhvec=zeros(Ldim,1); xhvec=zeros(Ldim,1); errvec=zeros(Ndim,1); htest=zeros(Ldim,1); fvec=zeros(Mdim,1); sfvec=zeros(Mdim,1);% delg=zeros(Ldim,1); hdelg=zeros(Ldim,1); uvec=zeros(Ldim,1); uhvec=zeros(Ldim,1); srhvec=zeros(Ldim,1); isrhvec=zeros(Ldim,1);% Ihess=zeros(Ldim,Ldim); hessL=zeros(Ldim,Ldim); RCMAT=zeros(Ndim,Ldim); Ihessofh=zeros(Ldim,Ldim);%RCMAT=RMAT*CMAT; Sigvec=Sigvec.^-1;mvec=ones(Ldim,1)/Ldim; errvec=RCMAT*mvec; mvec=mvec*sum(abs(Dvec))/sum(abs(errvec))*BASEPRESS;hvec=mvec; errvec=Sigvec.*(Dvec-RCMAT*hvec); grLvec=-RCMAT'*(Sigvec.*errvec);alpha=max(grLvec)-min(grLvec);%% Cross Validation Block%Xchis='N/A'; logXchis=1;if (Xlog)	Xchis=realmax; Xchismin=realmax;    cvd=zeros(Ndim,1); blocksize=round(Ndim*X_INTERVAL_FRAC);        for datum=1:X_INTERVALS        idx=ceil(Ndim*rand);        cvd(idx:min(idx+blocksize,Ndim))=1;    end        Xind=Ind(cvd==1); NX=length(Xind);	XDvec=Dvec(Xind); Dvec(Xind)=[];	XSigvec=Sigvec(Xind); Sigvec(Xind)=[];	sval(Xind)=[];	XRCMAT=RCMAT(Xind,:); RCMAT(Xind,:)=[];	Ndim=Ndim-NX;% 	fprintf('\n');% 	fprintf(FIO,'%s\n',['#FIT: ' num2str(Ndim) '  #CrossV: ' num2str(NX) '  Indices: ' num2str(Xind)]);% 	format='%10.3g %10.3g %10.3g %10.3g %10.3g %10.3g %10.3g %10.2g %10.2g %10.3g %10.3g %5d\n';endhessL=RCMAT'*diag(Sigvec.^2)*RCMAT; uhvec=sqrt(hvec);Ihess=eye(Ldim,Ldim);%% CENTRAL ANNEALING CYCLE%omega=0; aits=0; logALPHA=1;% if (~VERBlog) % 	fprintf('\n');% 	fprintf(FIO,sformat,'alpha','omega','Xchis','log(prD)','Q','chisq','Ichisq','entpy','Good','Bad','cScal','its');% endwhile (omega<OMEGA_STOP && logXchis && logALPHA)    aits=aits+1; alpha=max(alpha/COOLRATE,ALPHA_STOP);% 	if (VERBlog)% 		fprintf('\n');% 		fprintf(sformat,'alpha','omega','Xchis','log(prD)','Q','chisq','Ichisq','entpy','Good','Bad','cScal','its');% 	end	%    Ssca=sum(hvec-mvec-hvec.*log(hvec./mvec));    errvec=Sigvec.*(Dvec-RCMAT*hvec); Lsca=0.5*sum(errvec.*errvec); Qsca=Lsca-alpha*Ssca;    grSvec=-log(hvec./mvec);    grLvec=-RCMAT'*(errvec.*Sigvec); gveca=2*(grLvec-alpha*grSvec).*uhvec;	deluhvec=-Ihess*gveca; STPMAX=STPM*max(sqrt(uhvec'*uhvec),Ldim);	% LBFGS from numerical recipes    Xconvlog=0; GRDconvlog=0; hits=0;        while (~Xconvlog && ~GRDconvlog && hits<=ITSMAX)		hits=hits+1;        % BACKTRACK from numerical recipes        deluhvec=deluhvec*STPMAX/max(STPMAX,sqrt(deluhvec'*deluhvec));        lambdamin=min(TOLX/max(abs(deluhvec)./max(abs(uhvec),ones(Ldim,1))),0.9);        slope=gveca'*deluhvec; lambda1=1; BACKconvlog=0;        while (~BACKconvlog && lambda1>lambdamin)            uhtest=uhvec+lambda1*deluhvec; htest=uhtest.^2;            Ssca=sum(htest-mvec-htest.*log(htest./mvec));            errvec=Sigvec.*(Dvec-RCMAT*htest); Lsca=0.5*sum(errvec.*errvec); Qsca1=Lsca-alpha*Ssca;            if (lambda1==1)                newlambda=-slope/(2*(Qsca1-Qsca-slope));            else                rhs1=Qsca1-Qsca-lambda1*slope; rhs2=Qsca2-Qsca-lambda2*slope;                aval=(rhs1/lambda1^2-rhs2/lambda2^2)/(lambda1-lambda2);                bval=(-lambda2*rhs1/lambda1^2+lambda1*rhs2/lambda2^2)/(lambda1-lambda2);                if (aval==0)                    newlambda=-slope/(2*bval);                else                    disc=bval^2-3*aval*slope;                                        if (disc<0.0)                        disp('Warning: roundoff problem in backtrack');                        disc=abs(disc); %return                    else                        newlambda=(-bval+sqrt(disc))/(3*aval);                    end                end            end            if (Qsca1<=Qsca+TOLA*lambda1*slope)                BACKconvlog=1;            end                        newlambda=min(newlambda,0.5*lambda1); newlambda=max(newlambda,0.1*lambda1);            Qsca2=Qsca1; lambda2=lambda1; lambda1=newlambda;        end        lambda=lambda2; Qsca=Qsca2; deluhvec=lambda*deluhvec; uhvec=uhvec+deluhvec; hvec=uhvec.^2;        gvecb=gveca; errvec=Sigvec.*(Dvec-RCMAT*hvec);        grSvec=-log(hvec./mvec);        grLvec=-RCMAT'*(errvec.*Sigvec); gveca=2*(grLvec-alpha*grSvec).*uhvec;        delg=gveca-gvecb; hdelg=Ihess*delg;        fac=delg'*deluhvec; fae=delg'*hdelg; sumdg=delg'*delg; sumdh=deluhvec'*deluhvec;        if (fac^2 > EPS*sumdg*sumdh)            fac=fac^-1; fad=fae^-1; uvec=fac*deluhvec-fad*hdelg;            Ihess=Ihess+fac*deluhvec(:,:)*deluhvec'-fad*hdelg(:,:)*hdelg'+fae*uvec(:,:)*uvec';        end		%        if (max(abs(deluhvec)./max(abs(uhvec),ones(Ldim,1))) < TOLX)            Xconvlog=1;        end                if (max(abs(gveca).*max(abs(uhvec),ones(Ldim,1)))/max(Qsca,1.0) < GTOL)             GRDconvlog=1;        end        %        deluhvec=-Ihess*gveca;    end	%    Ssca=sum(hvec-mvec-hvec.*log(hvec./mvec));    errvec=Sigvec.*(Dvec-RCMAT*hvec); Lsca=0.5*sum(errvec.*errvec);	if (Xlog) 		Xerrvec=XSigvec.*(XDvec-XRCMAT*hvec);		Xchis=sum(Xerrvec.*Xerrvec)/NX;	end    Ivar=var(Dvec(sval>Szero))*sqrt(mean(Dvec.^2)/mean(Dvec(sval>Szero).^2));    Ichis=sum((Dvec-RCMAT*hvec).^2)/Ndim/Ivar;	%	% Comment out cscas evaluation to turn off auto-scaling of noise	cscas=2*(Lsca-alpha*Ssca)/Ndim;    % Q=(alpha*Ssca-Lsca)/cscas;    srhvec=(hvec.^0.5);    % approximate versus exact Gsca    % isrhvec=srhvec.^-1; Ihessofh=diag(2*uhvec)*Ihess*diag(2*uhvec);    % Gsca=trace(diag(isrhvec)*Ihessofh*hessL*diag(srhvec));    Gsca=trace((alpha*eye(Ldim)+diag(srhvec)*hessL*diag(srhvec))^-1*diag(srhvec)*hessL*diag(srhvec));    % detB=det(eye(Ldim)+diag(srhvec)*hessL*diag(srhvec)/alpha);	omega=(Gsca*cscas)/(-2*alpha*Ssca);	% logprD=-(Ndim/2)*log(2*pi*cscas)+logdetSIGinv+(alpha*Ssca-Lsca)/cscas-0.5*log(detB);	%% 	S=sprintf(format,alpha,omega,Xchis,logprD,Q,2*Lsca/Ndim,Ichis,Ssca,Gsca,2*Lsca/cscas,cscas^0.5,hits);% 	fprintf(FIO,'%s',S);    	%            if (Xlog)        logXchis=((Xchis-Xchismin)<tol*Xchismin | Ichis>2.0);        if (Xchis<Xchismin)            Xchismin=Xchis;        end                if (logXchis)            Xalpha=alpha; Xhvec=hvec; %Xstring=S;        end    end        if hits > ITSMAX	    disp('Warning: required tolerance not achieved in get_h');	    % return    end        if (aits>=3)        COOLRATE=min(COOLRATES(omega>OMEGA_SWITCH));    end    logALPHA=logical(alpha>ALPHA_STOP);end%if (Xlog)    hvec=Xhvec; alpha=Xalpha; %S=Xstring;endfvec=CMAT*hvec;%% if (Xlog && VERBlog)% 	fprintf('\n');% 	fprintf(FIO,'%s\n',['#FIT: ' num2str(Ndim) '  #CrossV: ' num2str(NX) '  Indices: ' num2str(Xind)]);% end%% if (~VERBlog)% 	fprintf('\n');% 	fprintf(FIO,sformat,'alpha','omega','Xchis','log(prD)','Q','chisq','Ichisq','entpy','Good','Bad','cScal','its');%     fprintf(FIO,'%s',S);% end% fprintf('\n');